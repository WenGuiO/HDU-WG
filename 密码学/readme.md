# 密码学
> 记录与保留密码学编程实现，为方便自身学习记录

## 1. Caesar
凯撒密码的实现简单，本次主要实现的是图形化界面。

**使用建议：**
- 直接使用JDK1.8来进行图形库导入
- 网上寻包手工导入

## 2. RC4
**函数功能**：使实现将任意长度的的字符串进行RC4加密。

**运行示例：**
```yaml
#输入要求:  任意长度字符

#示例--1
Enter plaintext: wweqw
plaintext(0-1): 
01110111 01110111 01100101 01110001 01110111 
Enter key: qeqe
keyStream --> LI¥(
keyStream(0-1): 
01001100 01001001 10011111 10100101 00101000 

Ciphertext --> ;>úÔ_
Ciphertext(0-1): 
00111011 00111110 11111010 11010100 01011111 

Decrypted text --> wweqw
Decrypted text(0-1): 
01110111 01110111 01100101 01110001 01110111 
```

## 3. DES
**函数功能**：使用**字符串操作**来代替**位运算**，实现将64bit的字符串进行DES加密，对于不足的字符串会自动进行补"0"填充。

**运行示例：**
```yaml
#输入要求:  长度不过8的字符串

#示例--1
请输入明文:	sdde
明文转换(0-1):0111001101100100011001000110010100000000000000000000000000000000
请输入秘钥:	sde
加密结果(0-1): 1110110111111000110101010011100111101111101010011010101110111110
加密结果：íøÕ9
解密结果(0-1)：0111001101100100011001000110010100000000000000000000000000000000
解密结果：sdde


#示例--2
请输入明文:	qwertyui
明文转换(0-1):0111000101110111011001010111001001110100011110010111010101101001
请输入秘钥:	qwertyui
加密结果(0-1): 1111010001011100111111000011100000011011100000110001011101111011
加密结果：ô\ü8{
解密结果(0-1)：0111000101110111011001010111001001110100011110010111010101101001
解密结果：qwertyui
```

> **注意:**  
> 1. 实际加密的明文并非输入的明文，而是进行“0”填充加密后的字符串，解密结果也只是截取了原明文长度，正常明文密文的长度是相同的。
> 2. 程序输入使用的是**sc.next()**，读到空格会结束输入，若想实现如“Hi RC!”的加密，可改为**sc.nextline()**。

## 4. SM4
### 4.1 SM4
**函数功能**：使用**位运算**，实现将128bit的16进制字符串进行SM4加密，对于不足的字符串会自动进行补"0"填充。

**运行示例：**
```yaml
#示例--1
输入要求:  长度不过32(不算0x)的以0x开头的16进制字符串

请输入明文: 0x0123456789abcdeffedcba9876543210
请输入密钥: 0x0123456789abcdeffedcba9876543210

加密结果: 0X681EDF34D206965E86B3E94F536E4246
解密结果: 0X0123456789ABCDEFFEDCBA9876543210


#示例--2
输入要求:  长度不过32(不算0x)的以0x开头的16进制字符串

请输入明文: 0x12345abcdef
请输入密钥: 0x12345fedcba

加密结果: 0X744FDAC2A51690221754356970FEC07B
解密结果: 0X12345ABCDEF
```
> **注意:**  实际加密的明文并非输入的明文，而是进行“0”填充加密后的字符串，解密结果也只是截取了原明文长度，正常明文密文的长度是相同的。

### 4.2 SM4_2

**函数功能：** 使用**位运算**，实现将输入的字符串进行SM4加密，对于不足的字符串会自动进行补"0"填充。

**与上诉SM4_1的区别: **
- 可输入任意不以0x，0X开头的长度不超过16的字符串来进行加密
- 可输入以0x开头的长度不超过32（不包括0x）的16进制字符串来进行加密

**运行示例：**
```yaml
#示例--1
输入要求:
	1.长度不过16的普通字符串
	2.长度不过32的以0x开头的16进制字符串

请输入明文(16以内): aiudhwudhuca
请输入密钥(16以内): agdywgdygd

加密结果为: ��0��6%Zmy�
解密结果为: aiudhwudhuca


#示例--2
输入要求:
	1.长度不过16的普通字符串
	2.长度不过32的以0x开头的16进制字符串

请输入明文(16以内): 0x1234567890abcdef12345
请输入密钥(16以内): 0x1234567890abcdef12345

加密结果为: 0X903243CFEED09949E4B49F67CBFEB967
解密结果为: 0X1234567890ABCDEF1234500000000000
```
> **注意：**  
> 1. 实际加密的明文并非输入的明文，而是进行“0”填充加密后的字符串，解密结果也只是截取了原明文长度，正常明文密文的长度是相同的。
> 2. 程序暂未对结果进行相关合理处理，在输入未达16位的字符串时，加密结果会截取与明文相同长度的字符，并未完整展示全部密文；在输入未达32位的16进制字符串时，解密结果也并未进行截取。

## 5. RSA
**函数功能**：实现将任意长度的字符串进行RSA加密。RSA的实现较为简单，比较难处理的是大数的表示以及运算，本程序通过调用java内部类BigInteger来实现。

**运行示例：**
```yaml
#输入要求:  任意长度的字符串

#示例--1
p = 871951705899788794107135622141
q = 792990757286488926312999762487
φ(n) = 691449643578719389999153648198949390776328227807609843040040

公钥(n, e):
	n = 691449643578719389999153648200614333239514505528029978424667
	e = 149767581948758359732066190381
私钥(n, d):
	n = 691449643578719389999153648200614333239514505528029978424667
	d = 548598971881589574659761730898960091399341986367770592960941

请输入明文: Hi, this is RSA!

密文: 237439262252967908532534882306214202673336773169393898006284

密文: %Ӆ���n{��w�{�h�^�

明文: Hi, this is RSA!
```


